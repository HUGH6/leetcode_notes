## 题目

给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。

如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。

 

示例 1：

> 输入：n = 1
> 输出：true
> 解释：20 = 1

示例 2：

> 输入：n = 16
> 输出：true
> 解释：24 = 16

示例 3：

> 输入：n = 3
> 输出：false

示例 4：

> 输入：n = 4
> 输出：true

示例 5：

> 输入：n = 5
> 输出：false


提示：

* -231 <= n <= 231 - 1


进阶：你能够不使用循环/递归解决此问题吗？

**链接：**

https://leetcode-cn.com/problems/power-of-two

## 思路

**位运算1**

由于负数和0肯定不是2的幂，因此只需要判断正数。如果n是2的幂，那么从二进制表示可以发现，二进制中只有一位是1，否则就不是2的幂。

因此可以判断n的二进制表示中1的个数。

最普通的方法是通过位移运算逐位比较是否是1，并记录个数。

**n & (n - 1)**

还有更方便的方法可以更快地计算1的个数，而不需要循环。

> n & (n - 1)

该位运算技巧可以直接将 n 二进制表示的最低位 1 移除，它的原理如下：

> 假设 n 的二进制表示为 (a10⋯0) ，其中 a 表示若干个高位，1 表示最低位的那个 1，0⋯0 表示后面的若干个 0
>
> 那么 n-1 的二进制表示为：(a01⋯1) 
>
> 将(a10⋯0) 与 (a01⋯1) 进行按位与运算，高位 a 不变，在这之后的所有位都会变为 0，这样就将最低位的那个 1 移除了。

因此，如果 n 是正整数并且 n & (n - 1) = 0，那么 n 就是 2 的幂。

**n & (-n)**

其中 −n 是 n 的相反数，是一个负数。该位运算技巧可以直接获取 n 二进制表示的最低位的 1。

由于负数是按照补码规则在计算机中存储的，−n 的二进制表示为 n 的二进制表示的每一位取反再加上 1，因此它的原理如下：

> 假设 n 的二进制表示为(a10⋯0) ，其中 a 表示若干个高位，1 表示最低位的那个 1，0⋯0 表示后面的若干个 0，那么 −n 的二进制表示为：
>
> ( ~a01⋯1) +(1) =( ~a10⋯0) 
>
> 将(a10⋯0) 与( ~a10⋯0) 进行按位与运算，高位全部变为 0，最低位的 1 以及之后的所有 0 不变，这样就获取了 n 二进制表示的最低位的 1。

因此，如果 n 是正整数并且n & (-n) = n，那么 n就是 2 的幂。

## 题解

循环


    class Solution {
        public boolean isPowerOfTwo(int n) {
            if (n <= 0) {
                return false;
            } else {
                int count = 0;
                while (n != 0) {
                    if ((n & 1) != 0) {
                        count++;
                    }
                    n = n >> 1;
                }
    
                return count == 1 ? true : false;
            }
    
        }
    }
    
    

**n & (n - 1)**

```
class Solution {
    public boolean isPowerOfTwo(int n) {
        return n > 0 && (n & (n - 1)) == 0;
    }
}

```

**n & (-n)**

```
class Solution {
    public boolean isPowerOfTwo(int n) {
        return n > 0 && (n & -n) == n;
    }
}

```

