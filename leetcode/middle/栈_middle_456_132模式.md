## 题目

给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i < j < k 和 nums[i] < nums[k] < nums[j] 。

如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。

示例 1：

> 输入：nums = [1,2,3,4]
> 输出：false
> 解释：序列中不存在 132 模式的子序列。

示例 2：

> 输入：nums = [3,1,4,2]
> 输出：true
> 解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。

示例 3：

> 输入：nums = [-1,3,2,0]
> 输出：true
> 解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。


提示：

* n == nums.length
* 1 <= n <= 2 * 105
* -109 <= nums[i] <= 109

**链接：**

https://leetcode-cn.com/problems/132-pattern

## 思路

由于本题中 n 的最大值可以到 2 x 10^5 ，因此对于一个满足 132 模式的三元组下标 (i, j, k)(i,j,k)，枚举其中的 2 个下标时间复杂度为 O(n^2)，会超出时间限制。

因此我们可以考虑枚举其中的 1 个下标，并使用合适的数据结构维护另外的 2 个下标的可能值。

**枚举3：1的最小值+TreeMap**

时间：O（nlogn）

空间：O（n）

枚举 3 是容易想到并且也是最容易实现的。由于 3 是模式中的最大值，并且其出现在 1 和 2 的中间，因此只需要从左到右枚举 3 的下标 j，那么：

* 由于 1 是模式中的最小值，因此我们在枚举 j 的同时，维护数组 a 中左侧元素 a[0..j−1] 的最小值，即为 1 对应的元素 a[i]。需要注意的是，只有 a[i]<a[j] 时，a[i]才能作为 1 对应的元素；

* 由于 2 是模式中的次小值，因此可以使用一个有序集合（例如平衡树）维护数组 a 中右侧元素a[j+1..n−1] 中的所有值。当我们确定了 aa[i] 和a[j] 之后，只需要在有序集合中查询严格比 a[i] 大的那个最小的元素，即为 a[k]。需要注意的是，只有a[k]<a[j] 时，a[k] 才能作为 3 对应的元素。

**枚举1：单调栈找2和3**

时间：O（n）

空间：O（n）

也可以枚举1,1是132中的最小值，那么，就需要一个数据结构或方法能够在枚举1的过程中找到2和3。

如果从左到右枚举 1 的下标 i，那么 j, k的下标范围都是减少的，这样就不利于对它们进行维护。因此可以考虑从右到左枚举i。

由于1最小，2和3都比1大，那么在从右到左遍历1的过程中，可以使用一种数据结构维护所有遍历过的元素，它们作为 2 的候选元素。每当我们遍历到一个新的元素时，就将其加入数据结构中；

* 由于这些2的候选元素已经保存了起来，我们还需要找到3,3是最大元素，因此，在遍历到一个新的元素的同时，可以考虑其是否可以作为3。（即，和维护的2候选元素比较，如果有2的候选元素比该元素小，则说明当前元素可以作为3，使用一个变量维护所有被移除的元素的最大值，而这些比较过的2候选元素可以去除）
* 这些被移除的元素都是可以真正作为 2 的，并且元素的值越大，那么我们之后找到 1 的机会也就越大。

那么这个「数据结构」是什么样的数据结构呢？我们尝试提取出它进行的操作：

* 它需要支持添加一个元素；

* 它需要支持移除所有严格小于给定阈值的所有元素；

* 上面两步操作是「依次进行」的，即先用给定的阈值移除元素，再将该阈值加入数据结构中。

这就是「单调栈」。在单调栈中，从栈底到栈顶的元素是严格单调递减的。当给定阈值 x 时，只需要不断地弹出栈顶的元素，直到栈为空或者 x 严格小于栈顶元素。此时我们再将 x 入栈，这样就维护了栈的单调性。

因此，可以使用单调栈作为维护 2 的数据结构，并给出下面的算法：

* 用单调栈维护所有可以作为2 的候选元素。初始时，单调栈中只有唯一的元素 a[n−1]。
* 需要使用一个变量 max_k 记录所有可以真正作为2 的元素的最大值；

* 随后从 n−2 开始从右到左枚举元素 a[i]：
  * 首先判断a[i] 是否可以作为 1。如果 a[i] < max_k，那么它就可以作为1，我们就找到了一组满足 132 模式的三元组；
  * 随后判断a[i] 是否可以作为 3，以此找出哪些可以真正作为 2 的元素。将 a[i] 不断地与单调栈栈顶的元素进行比较，如果 a[i] 较大，那么栈顶元素可以真正作为 2，将其弹出并更新 max_k；
  * 最后将 a[i] 作为 2 的候选元素放入单调栈中。这里可以进行一个优化，即如果 a[i]≤max_k，那么我们也没有必要将 a[i]放入栈中，因为即使它在未来被弹出，也不会将 max_k 更新为更大的值。

在枚举完所有的元素后，如果仍未找到满足132 模式的三元组，那就说明其不存在。

## 题解

**枚举3：1的最小值+TreeMap**


    class Solution {
        public boolean find132pattern(int[] nums) {
            if (nums.length < 3) {
                return false;
            }
    
            int leftMin = nums[0];
            TreeMap<Integer, Integer> rightAll = new TreeMap<>();
            for (int i = 2; i < nums.length; i++) {
                rightAll.put(nums[i], rightAll.getOrDefault(nums[i], 0) + 1);
            }
    
            for (int j = 1; j < nums.length - 1; j++) {
                if (leftMin < nums[j]) {
                    Integer next = rightAll.ceilingKey(leftMin + 1);
                    if (next != null && next < nums[j]) {
                        return true;
                    }
                }
                leftMin = Math.min(leftMin, nums[j]);
                rightAll.put(nums[j + 1], rightAll.get(nums[j + 1]) - 1);
                if (rightAll.get(nums[j + 1]) == 0) {
                    rightAll.remove(nums[j + 1]);
                }
            }
    
            return false;
        }
    }


​    

**枚举1：单调栈找2和3**

```
class Solution {
    public boolean find132pattern(int[] nums) {
        Stack<Integer> stack = new Stack<>();
        int maxK = Integer.MIN_VALUE;
        int len = nums.length;
        stack.push(nums[len - 1]);

        for (int i = len - 2; i >= 0; i--) {
            if (nums[i] < maxK) {
                return true;
            }
            while (!stack.empty() && stack.peek() < nums[i]) {
                maxK = stack.pop();
            }

            stack.push(nums[i]);
        }

        return false;
    }
}
```

